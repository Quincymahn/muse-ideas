/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import { AnimationMixer, Object3D } from "three";
import { useEffect, useLayoutEffect, useRef, useState } from "react";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { GroupProps, useFrame } from "@react-three/fiber";
import { SkeletonUtils } from "../utils/SkeletonUtils";

type GLTFResult = GLTF & {
  nodes: {
    avatar: THREE.SkinnedMesh;
    mixamorigHips: THREE.Bone;
    Armature: Object3D;
  };
  materials: {
    ["avatar.mat"]: THREE.MeshStandardMaterial;
  };
};

type ActionName = "swimmin" | "idle" | "lay" | "wave";
type GLTFActions = Record<ActionName, THREE.AnimationAction>;

const FILE_URL =
  "https://d27rt3a60hh1lx.cloudfront.net/models/SwimmingMort-1627646231/mort.glb.gz";

type ModelProps = {
  animation?: ActionName;
  duration?: number;
} & GroupProps;

export default function Model(props: ModelProps) {
  const { animation = "idle", duration = 0.5, ...rest } = props;

  const { nodes, animations, materials } = useGLTF(FILE_URL) as GLTFResult;

  materials["avatar.mat"].metalness = 0.2;
  materials["avatar.mat"].roughness = 0.5;

  // main data
  const [armature, setArmature] = useState<Object3D | undefined>();
  const [mixer, setMixer] = useState<AnimationMixer | undefined>();

  // anim stuff
  const actions = useRef<GLTFActions>();
  const previousAction = useRef(animation);

  const fadeToAction = (name: ActionName, duration = 0.2) => {
    const acts = actions?.current;
    if (!acts) return;
    if (name === previousAction.current) return;

    if (acts[previousAction.current].enabled) {
      acts[previousAction.current].fadeOut(duration);
    }

    acts[name]
      .reset()
      .setEffectiveTimeScale(1)
      .setEffectiveWeight(1)
      .fadeIn(duration)
      .play();

    previousAction.current = name;
  };

  useLayoutEffect(() => {
    if (!nodes) return;

    // create new armature
    const newArmature = SkeletonUtils.clone(nodes.Armature) as Object3D;
    const newMixer = new THREE.AnimationMixer(newArmature);

    // see meshes up close, need this shit bruv
    newArmature.traverse((obj) => (obj.frustumCulled = false));

    // load all actions and play selected one
    actions.current = animations.reduce((acc, cur) => {
      const name = cur.name as ActionName;
      acc[name] = newMixer.clipAction(cur, newArmature);
      return acc;
    }, {} as GLTFActions);

    actions.current[animation].play();
    setArmature(newArmature);
    setMixer(newMixer);
  }, [nodes]);

  useEffect(() => {
    if (!armature || !actions.current) return;
    fadeToAction(animation, duration);
  }, [animation, armature, actions]);

  // update animation every frame
  useFrame((_, delta) => mixer && mixer.update(delta));

  return (
    <group {...rest}>
      <mesh
        position-y={0.5}
        name="hitbox"
        material={materials["avatar.mat"]}
        visible={false}
      >
        <boxBufferGeometry args={[0.35, 1, 0.35]} />
      </mesh>
      <group name="Armature" scale={0.615} frustumCulled={false}>
        {armature && <primitive object={armature} />}
      </group>
    </group>
  );
}

useGLTF.preload(FILE_URL);
